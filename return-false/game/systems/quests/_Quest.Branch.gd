## Parsing and handling NPC dialogue branches

var dialog_label
var parent_quest
var states
onready var QM = get_tree().get_current_scene().find_node("QuestManager")
onready var MUI = get_tree().get_current_scene().find_node("MessageUI")

func _init(data):
	for key in data:
		self[key] = data[key]

func has_state(state_id):
	return states.has(state_id)

func _at_state(state_id):
	if has_state(state_id):
		return states.state_id

func text_at_state(state_id):
	if has_state(state_id) and _at_state(state_id).has('dialogue'):
		return _at_state(state_id).dialogue

func responses_at_state(state_id):
	if has_state(state_id) and _at_state(state_id).has('responses'):
		return _at_state(state_id).responses


## These methods are related to the response options
# generated by the MessageUI using this branch's data.

func build_response(data):
	var btn = MUI.response(data.text, [])
	var fn = null
	var arg

	if data.has('new_state'):
		arg = data.new_state
		if data.dialog_action == 1:
			fn = 'update_and_continue'
		else:
			fn = 'update_and_close'

	else:
		fn = 'end_dialog'

	if fn:
		btn.connect('pressed', self, fn, [arg])


func update_and_close(new_state):
	QM.set_state(parent_quest, new_state)
	MUI.close()

func update_and_continue(new_state):
	QM.set_state(parent_quest, new_state)
	MUI.clear()
	MUI.say(text_at_state(new_state))
	for r in responses_at_state(new_state):
		MUI.response(build_response(r))

func end_dialog():
	MUI.close()
	MUI.clear()
